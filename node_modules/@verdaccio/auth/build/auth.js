"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Auth = void 0;
var _debug = _interopRequireDefault(require("debug"));
var _lodash = _interopRequireDefault(require("lodash"));
var _verdaccioHtpasswd = require("verdaccio-htpasswd");
var _config = require("@verdaccio/config");
var _core = require("@verdaccio/core");
var _loaders = require("@verdaccio/loaders");
var _signature = require("@verdaccio/signature");
var _utils = require("@verdaccio/utils");
var _utils2 = require("./utils");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('verdaccio:auth');
class Auth {
  constructor(config, logger) {
    this.config = config;
    this.secret = config.secret;
    this.logger = logger;
    this.plugins = [];
    if (!this.secret) {
      throw new TypeError('secret it is required value on initialize the auth class');
    }
  }
  async init() {
    let plugins = await this.loadPlugin();
    debug('auth plugins found %s', plugins.length);
    if (!plugins || plugins.length === 0) {
      plugins = this.loadDefaultPlugin();
    }
    this.plugins = plugins;
    this._applyDefaultPlugins();
  }
  loadDefaultPlugin() {
    debug('load default auth plugin');
    const pluginOptions = {
      config: this.config,
      logger: this.logger
    };
    let authPlugin;
    try {
      authPlugin = new _verdaccioHtpasswd.HTPasswd({
        file: './htpasswd'
      }, pluginOptions);
      this.logger.info({
        name: 'verdaccio-htpasswd',
        pluginCategory: _core.PLUGIN_CATEGORY.AUTHENTICATION
      }, 'plugin @{name} successfully loaded (@{pluginCategory})');
    } catch (error) {
      debug('error on loading auth htpasswd plugin stack: %o', error);
      this.logger.info({}, 'no auth plugin has been found');
      return [];
    }
    return [authPlugin];
  }
  async loadPlugin() {
    return (0, _loaders.asyncLoadPlugin)(this.config.auth, {
      config: this.config,
      logger: this.logger
    }, plugin => {
      const {
        authenticate,
        allow_access,
        allow_publish
      } = plugin;
      return typeof authenticate !== 'undefined' || typeof allow_access !== 'undefined' || typeof allow_publish !== 'undefined';
    }, this.config?.serverSettings?.pluginPrefix, _core.PLUGIN_CATEGORY.AUTHENTICATION);
  }
  _applyDefaultPlugins() {
    // TODO: rename to applyFallbackPluginMethods
    this.plugins.push((0, _utils2.getDefaultPlugins)(this.logger));
  }
  changePassword(username, password, newPassword, cb) {
    const validPlugins = _lodash.default.filter(this.plugins, plugin => (0, _utils.isFunction)(plugin.changePassword));
    if (_lodash.default.isEmpty(validPlugins)) {
      return cb(_core.errorUtils.getInternalError(_core.SUPPORT_ERRORS.PLUGIN_MISSING_INTERFACE));
    }
    for (const plugin of validPlugins) {
      if ((0, _utils.isNil)(plugin) || (0, _utils.isFunction)(plugin.changePassword) === false) {
        debug('auth plugin does not implement changePassword, trying next one');
        continue;
      } else {
        debug('updating password for %o', username);
        plugin.changePassword(username, password, newPassword, (err, profile) => {
          if (err) {
            this.logger.error({
              username,
              err
            }, `An error has been produced
            updating the password for @{username}. Error: @{err.message}`);
            return cb(err);
          }
          debug('updated password for %o was successful', username);
          return cb(null, profile);
        });
      }
    }
  }
  async invalidateToken(token) {
    // eslint-disable-next-line no-console
    console.log('invalidate token pending to implement', token);
    return Promise.resolve();
  }
  authenticate(username, password, cb) {
    const plugins = this.plugins.slice(0);
    (function next() {
      const plugin = plugins.shift();
      if ((0, _utils.isFunction)(plugin.authenticate) === false) {
        return next();
      }
      debug('authenticating %o', username);
      plugin.authenticate(username, password, function (err, groups) {
        if (err) {
          debug('authenticating for user %o failed. Error: %o', username, err?.message);
          return cb(err);
        }

        // Expect: SKIP if groups is falsey and not an array
        //         with at least one item (truthy length)
        // Expect: CONTINUE otherwise (will error if groups is not
        //         an array, but this is current behavior)
        // Caveat: STRING (if valid) will pass successfully
        //         bug give unexpected results
        // Info: Cannot use `== false to check falsey values`
        if (!!groups && groups.length !== 0) {
          // TODO: create a better understanding of expectations
          if (_lodash.default.isString(groups)) {
            throw new TypeError('plugin group error: invalid type for function');
          }
          const isGroupValid = _lodash.default.isArray(groups);
          if (!isGroupValid) {
            throw new TypeError(_core.API_ERROR.BAD_FORMAT_USER_GROUP);
          }
          debug('authentication for user %o was successfully. Groups: %o', username, groups);
          return cb(err, (0, _config.createRemoteUser)(username, groups));
        }
        next();
      });
    })();
  }
  add_user(user, password, cb) {
    const self = this;
    const plugins = this.plugins.slice(0);
    debug('add user %o', user);
    (function next() {
      let method = 'adduser';
      const plugin = plugins.shift();
      // @ts-expect-error future major (7.x) should remove this section
      if (typeof plugin.adduser === 'undefined' && typeof plugin.add_user === 'function') {
        method = 'add_user';
        _core.warningUtils.emit(_core.warningUtils.Codes.VERWAR006);
      }
      // @ts-ignore
      if (typeof plugin[method] !== 'function') {
        next();
      } else {
        // TODO: replace by adduser whenever add_user deprecation method has been removed
        // @ts-ignore
        plugin[method](user, password, function (err, ok) {
          if (err) {
            debug('the user %o could not be added. Error: %o', user, err?.message);
            return cb(err);
          }
          if (ok) {
            debug('the user %o has been added', user);
            return self.authenticate(user, password, cb);
          }
          debug('user could not be added, skip to next auth plugin');
          next();
        });
      }
    })();
  }

  /**
   * Allow user to access a package.
   */
  allow_access({
    packageName,
    packageVersion
  }, user, callback) {
    const plugins = this.plugins.slice(0);
    const pkgAllowAccess = {
      name: packageName,
      version: packageVersion
    };
    const pkg = Object.assign({}, pkgAllowAccess, (0, _utils.getMatchedPackagesSpec)(packageName, this.config.packages));
    debug('allow access for %o', packageName);
    (function next() {
      const plugin = plugins.shift();
      if (_lodash.default.isNil(plugin) || (0, _utils.isFunction)(plugin.allow_access) === false) {
        return next();
      }
      plugin.allow_access(user, pkg, function (err, ok) {
        if (err) {
          debug('forbidden access for %o. Error: %o', packageName, err?.message);
          return callback(err);
        }
        if (ok) {
          debug('allowed access for %o', packageName);
          return callback(null, ok);
        }
        next(); // cb(null, false) causes next plugin to roll
      });
    })();
  }
  allow_unpublish({
    packageName,
    packageVersion
  }, user, callback) {
    const pkg = Object.assign({
      name: packageName,
      version: packageVersion
    }, (0, _utils.getMatchedPackagesSpec)(packageName, this.config.packages));
    debug('allow unpublish for %o', packageName);
    for (const plugin of this.plugins) {
      if (typeof plugin?.allow_unpublish !== 'function') {
        debug('allow unpublish for %o plugin does not implement allow_unpublish', packageName);
        continue;
      } else {
        plugin.allow_unpublish(user, pkg, (err, ok) => {
          if (err) {
            debug('forbidden publish for %o, it will fallback on unpublish permissions', packageName);
            return callback(err);
          }
          if (_lodash.default.isNil(ok) === true) {
            debug('bypass unpublish for %o, publish will handle the access', packageName);
            return this.allow_publish({
              packageName,
              packageVersion
            }, user, callback);
          }
          if (ok) {
            debug('allowed unpublish for %o', packageName);
            return callback(null, ok);
          }
        });
      }
    }
  }

  /**
   * Allow user to publish a package.
   */
  allow_publish({
    packageName,
    packageVersion
  }, user, callback) {
    const plugins = this.plugins.slice(0);
    const pkg = Object.assign({
      name: packageName,
      version: packageVersion
    }, (0, _utils.getMatchedPackagesSpec)(packageName, this.config.packages));
    debug('allow publish for %o init | plugins: %o', packageName, plugins.length);
    (function next() {
      const plugin = plugins.shift();
      if (typeof plugin?.allow_publish !== 'function') {
        debug('allow publish for %o plugin does not implement allow_publish', packageName);
        return next();
      }
      plugin.allow_publish(user, pkg, (err, ok) => {
        if (_lodash.default.isNil(err) === false && _lodash.default.isError(err)) {
          debug('forbidden publish for %o', packageName);
          return callback(err);
        }
        if (ok) {
          debug('allowed publish for %o', packageName);
          return callback(null, ok);
        }
        debug('allow publish skip validation for %o', packageName);
        next(); // cb(null, false) causes next plugin to roll
      });
    })();
  }
  apiJWTmiddleware() {
    debug('jwt middleware');
    const plugins = this.plugins.slice(0);
    const helpers = {
      createAnonymousRemoteUser: _config.createAnonymousRemoteUser,
      createRemoteUser: _config.createRemoteUser
    };
    for (const plugin of plugins) {
      if (plugin.apiJWTmiddleware) {
        return plugin.apiJWTmiddleware(helpers);
      }
    }
    return (req, res, _next) => {
      req.pause();
      const next = function (err) {
        req.resume();
        // uncomment this to reject users with bad auth headers
        // return _next.apply(null, arguments)
        // swallow error, user remains unauthorized
        // set remoteUserError to indicate that user was attempting authentication
        if (err) {
          req.remote_user.error = err.message;
        }
        return _next();
      };

      // FUTURE: disabled, not removed yet but seems unreacable code
      // if (this._isRemoteUserValid(req.remote_user)) {
      //   debug('jwt has a valid authentication header');
      //   return next();
      // }

      // in case auth header does not exist we return anonymous function
      const remoteUser = (0, _config.createAnonymousRemoteUser)();
      req.remote_user = remoteUser;
      res.locals.remote_user = remoteUser;
      const {
        authorization
      } = req.headers;
      if (_lodash.default.isNil(authorization)) {
        debug('jwt, authentication header is missing');
        return next();
      }
      if (!(0, _utils2.isAuthHeaderValid)(authorization)) {
        debug('api middleware authentication heather is invalid');
        return next(_core.errorUtils.getBadRequest(_core.API_ERROR.BAD_AUTH_HEADER));
      }
      const {
        secret,
        security
      } = this.config;
      if ((0, _utils2.isAESLegacy)(security)) {
        debug('api middleware using legacy auth token');
        this.handleAESMiddleware(req, security, secret, authorization, next);
      } else {
        debug('api middleware using JWT auth token');
        this.handleJWTAPIMiddleware(req, security, secret, authorization, next);
      }
    };
  }
  handleJWTAPIMiddleware(req, security, secret, authorization, next) {
    debug('handle JWT api middleware');
    const {
      scheme,
      token
    } = (0, _utils2.parseAuthTokenHeader)(authorization);
    if (scheme.toUpperCase() === _core.TOKEN_BASIC.toUpperCase()) {
      debug('handle basic token');
      // this should happen when client tries to login with an existing user
      const credentials = (0, _utils2.convertPayloadToBase64)(token).toString();
      const {
        user,
        password
      } = (0, _signature.parseBasicPayload)(credentials);
      debug('authenticating %o', user);
      this.authenticate(user, password, (err, user) => {
        if (!err) {
          debug('generating a remote user');
          req.remote_user = user;
          next();
        } else {
          debug('generating anonymous user');
          req.remote_user = (0, _config.createAnonymousRemoteUser)();
          next(err);
        }
      });
    } else {
      debug('handle jwt token');
      const credentials = (0, _utils2.getMiddlewareCredentials)(security, secret, authorization);
      if (credentials) {
        // if the signature is valid we rely on it
        req.remote_user = credentials;
        debug('generating a remote user');
        next();
      } else {
        // with JWT throw 401
        debug('jwt invalid token');
        next(_core.errorUtils.getForbidden(_core.API_ERROR.BAD_USERNAME_PASSWORD));
      }
    }
  }
  handleAESMiddleware(req, security, secret, authorization, next) {
    debug('handle legacy api middleware');
    debug('api middleware has a secret? %o', typeof secret === 'string');
    debug('api middleware authorization %o', typeof authorization === 'string');
    const credentials = (0, _utils2.getMiddlewareCredentials)(security, secret, authorization);
    debug('api middleware credentials %o', credentials?.name);
    if (credentials) {
      const {
        user,
        password
      } = credentials;
      debug('authenticating %o', user);
      this.authenticate(user, password, (err, user) => {
        if (!err) {
          req.remote_user = user;
          debug('generating a remote user');
          next();
        } else {
          req.remote_user = (0, _config.createAnonymousRemoteUser)();
          debug('generating anonymous user');
          next(err);
        }
      });
    } else {
      // we force npm client to ask again with basic authentication
      debug('legacy invalid header');
      return next(_core.errorUtils.getBadRequest(_core.API_ERROR.BAD_AUTH_HEADER));
    }
  }
  _isRemoteUserValid(remote_user) {
    return _lodash.default.isUndefined(remote_user) === false && _lodash.default.isUndefined(remote_user?.name) === false;
  }

  /**
   * JWT middleware for WebUI
   */
  webUIJWTmiddleware() {
    return (req, res, _next) => {
      if (this._isRemoteUserValid(req.remote_user)) {
        return _next();
      }
      req.pause();
      const next = err => {
        req.resume();
        if (err) {
          req.remote_user.error = err.message;
          res.status(err.statusCode).send(err.message);
        }
        return _next();
      };
      const {
        authorization
      } = req.headers;
      if (_lodash.default.isNil(authorization)) {
        return next();
      }
      if (!(0, _utils2.isAuthHeaderValid)(authorization)) {
        return next(_core.errorUtils.getBadRequest(_core.API_ERROR.BAD_AUTH_HEADER));
      }
      const token = (authorization || '').replace(`${_core.TOKEN_BEARER} `, '');
      if (!token) {
        return next();
      }
      let credentials;
      try {
        credentials = (0, _utils2.verifyJWTPayload)(token, this.config.secret);
      } catch (err) {
        // FIXME: intended behaviour, do we want it?
      }
      if (this._isRemoteUserValid(credentials)) {
        const {
          name,
          groups
        } = credentials;
        req.remote_user = (0, _config.createRemoteUser)(name, groups);
      } else {
        req.remote_user = (0, _config.createAnonymousRemoteUser)();
      }
      next();
    };
  }
  async jwtEncrypt(user, signOptions) {
    const {
      real_groups,
      name,
      groups
    } = user;
    debug('jwt encrypt %o', name);
    const realGroupsValidated = _lodash.default.isNil(real_groups) ? [] : real_groups;
    const groupedGroups = _lodash.default.isNil(groups) ? real_groups : Array.from(new Set([...groups.concat(realGroupsValidated)]));
    const payload = {
      real_groups: realGroupsValidated,
      name,
      groups: groupedGroups
    };
    const token = await (0, _signature.signPayload)(payload, this.secret, signOptions);
    return token;
  }

  /**
   * Encrypt a string.
   */
  aesEncrypt(value) {
    if (this.secret.length === _signature.utils.TOKEN_VALID_LENGTH) {
      debug('signing with enhanced aes legacy');
      const token = (0, _signature.aesEncrypt)(value, this.secret);
      return token;
    } else {
      debug('signing with enhanced aes deprecated legacy');
      // deprecated aes (legacy) signature, only must be used for legacy version
      const token = (0, _signature.aesEncryptDeprecated)(Buffer.from(value), this.secret).toString('base64');
      return token;
    }
  }
}
exports.Auth = Auth;
//# sourceMappingURL=auth.js.map