{"version":3,"file":"plugin-utils.js","names":["Plugin","version","constructor","config","options","getVersion","exports"],"sources":["../src/plugin-utils.ts"],"sourcesContent":["import { Express, RequestHandler } from 'express';\nimport { Readable, Writable } from 'stream';\n\nimport {\n  AllowAccess,\n  Callback,\n  Config,\n  Logger,\n  Manifest,\n  PackageAccess,\n  RemoteUser,\n  Token,\n  TokenFilter,\n} from '@verdaccio/types';\n\nimport { VerdaccioError, searchUtils } from '.';\n\nexport interface AuthPluginPackage {\n  packageName: string;\n  packageVersion?: string;\n  tag?: string;\n}\nexport interface PluginOptions {\n  config: Config;\n  logger: Logger;\n}\n\n/**\n * The base plugin class, set of utilities for developing\n * plugins.\n * @alpha\n * */\nexport class Plugin<PluginConfig> {\n  static version = 1;\n  public readonly version: number;\n  public readonly config: PluginConfig | unknown;\n  public readonly options: PluginOptions;\n  public constructor(config: PluginConfig, options: PluginOptions) {\n    this.version = Plugin.version;\n    this.config = config;\n    this.options = options;\n  }\n\n  public getVersion() {\n    return this.version;\n  }\n}\nexport interface StorageHandler {\n  logger: Logger;\n  deletePackage(fileName: string): Promise<void>;\n  removePackage(): Promise<void>;\n  //  next packages migration (this list is meant to replace the callback parent functions)\n  updatePackage(\n    packageName: string,\n    handleUpdate: (manifest: Manifest) => Promise<Manifest>\n  ): Promise<Manifest>;\n  readPackage(name: string): Promise<Manifest>;\n  savePackage(pkgName: string, value: Manifest): Promise<void>;\n  readTarball(pkgName: string, { signal }: { signal: AbortSignal }): Promise<Readable>;\n  createPackage(name: string, manifest: Manifest): Promise<void>;\n  writeTarball(tarballName: string, { signal }: { signal: AbortSignal }): Promise<Writable>;\n  // verify if tarball exist in the storage\n  hasTarball(fileName: string): Promise<boolean>;\n  // verify if package exist in the storage\n  hasPackage(): Promise<boolean>;\n}\n\nexport interface Storage<PluginConfig> extends Plugin<PluginConfig> {\n  add(name: string): Promise<void>;\n  remove(name: string): Promise<void>;\n  get(): Promise<any>;\n  init(): Promise<void>;\n  getSecret(): Promise<string>;\n  setSecret(secret: string): Promise<any>;\n  getPackageStorage(packageInfo: string): StorageHandler;\n  search(query: searchUtils.SearchQuery): Promise<searchUtils.SearchItem[]>;\n  saveToken(token: Token): Promise<any>;\n  deleteToken(user: string, tokenKey: string): Promise<any>;\n  readTokens(filter: TokenFilter): Promise<Token[]>;\n}\n\n/**\n * This function allow add additional middleware to the application.\n *\n *  ```ts\n *  import express, { Request, Response } from 'express';\n * \n *  class Middleware extends Plugin {\n *    // instances of auth and storage are injected\n *    register_middlewares(app, auth, storage) {\n *      const router = express.Router();\n *      router.post('/my-endpoint', (req: Request, res: Response): void => {\n        res.status(200).end();\n      });\n *    }\n *  }\n * \n *  \n *  const [plugin] = await asyncLoadPlugin(...);\n *  plugin.register_middlewares(app, auth, storage);\n *  ```\n */\nexport interface ExpressMiddleware<PluginConfig, Storage, Auth> extends Plugin<PluginConfig> {\n  register_middlewares(app: Express, auth: Auth, storage: Storage): void;\n}\n\n/**\n * dasdsa\n */\nexport type AuthCallback = (error: VerdaccioError | null, groups?: string[] | false) => void;\n\nexport type AuthAccessCallback = (error: VerdaccioError | null, access?: boolean) => void;\nexport type AuthUserCallback = (error: VerdaccioError | null, access?: boolean | string) => void;\nexport type AuthChangePasswordCallback = (error: VerdaccioError | null, access?: boolean) => void;\nexport type AccessCallback = (error: VerdaccioError | null, ok?: boolean) => void;\nexport interface Auth<T> extends Plugin<T> {\n  /**\n   * Handles the authenticated method.\n   * ```ts\n   *  class Auth {\n      public authenticate(user: string, password: string, done: AuthCallback): void {\n        if (!password) {\n          return done(errorUtils.getUnauthorized(API_ERROR.BAD_USERNAME_PASSWORD));\n        }\n        // always return an array of users\n        return done(null, [user]);      \n   *  }\n   * ```\n   */\n  authenticate(user: string, password: string, cb: AuthCallback): void;\n  /**\n   * Handles the authenticated method.\n   * ```ts\n   *  class Auth {\n      public adduser(user: string, password: string, done: AuthCallback): void {\n        if (!password) {\n          return done(errorUtils.getUnauthorized(API_ERROR.BAD_USERNAME_PASSWORD));\n        }\n        // return boolean\n        return done(null, true);      \n   *  }\n   * ```\n   */\n  adduser?(user: string, password: string, cb: AuthUserCallback): void;\n  changePassword?(\n    user: string,\n    password: string,\n    newPassword: string,\n    cb: AuthChangePasswordCallback\n  ): void;\n  allow_publish?(user: RemoteUser, pkg: T & PackageAccess, cb: AuthAccessCallback): void;\n  allow_publish?(user: RemoteUser, pkg: AllowAccess & PackageAccess, cb: AuthAccessCallback): void;\n  allow_access?(user: RemoteUser, pkg: T & PackageAccess, cb: AccessCallback): void;\n  allow_access?(user: RemoteUser, pkg: AllowAccess & PackageAccess, cb: AccessCallback): void;\n  allow_unpublish?(user: RemoteUser, pkg: T & PackageAccess, cb: AuthAccessCallback): void;\n  allow_unpublish?(\n    user: RemoteUser,\n    pkg: AllowAccess & PackageAccess,\n    cb: AuthAccessCallback\n  ): void;\n  apiJWTmiddleware?(helpers: any): RequestHandler;\n}\n\nexport interface IBasicAuth {\n  authenticate(user: string, password: string, cb: Callback): void;\n  invalidateToken?(token: string): Promise<void>;\n  changePassword(user: string, password: string, newPassword: string, cb: Callback): void;\n  allow_access(pkg: AuthPluginPackage, user: RemoteUser, callback: Callback): void;\n  add_user(user: string, password: string, cb: Callback): any;\n}\n\nexport interface ManifestFilter<T> extends Plugin<T> {\n  filter_metadata(packageInfo: Manifest): Promise<Manifest>;\n}\n"],"mappings":";;;;;;AA2BA;AACA;AACA;AACA;AACA;AACO,MAAMA,MAAM,CAAe;EAChC,OAAOC,OAAO,GAAG,CAAC;EAIXC,WAAWA,CAACC,MAAoB,EAAEC,OAAsB,EAAE;IAC/D,IAAI,CAACH,OAAO,GAAGD,MAAM,CAACC,OAAO;IAC7B,IAAI,CAACE,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,OAAO,GAAGA,OAAO;EACxB;EAEOC,UAAUA,CAAA,EAAG;IAClB,OAAO,IAAI,CAACJ,OAAO;EACrB;AACF;;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAKA;AACA;AACA;AAFAK,OAAA,CAAAN,MAAA,GAAAA,MAAA","ignoreList":[]}